{
  "problems": [
    {
      "id": "two-sum",
      "title": "Two Sum",
      "difficulty": "Easy",
      "level": 1,
      "category": "Arrays",
      "tags": ["Array", "Hash Table", "Two Pointers"],
      "companies": [
        {
          "name": "Meta",
          "frequency": "Very High",
          "lastAsked": "2024-12-10"
        },
        {
          "name": "Amazon", 
          "frequency": "High",
          "lastAsked": "2024-12-08"
        },
        {
          "name": "Google",
          "frequency": "Medium",
          "lastAsked": "2024-11-25"
        }
      ],
      "statistics": {
        "totalSubmissions": 4567890,
        "acceptedSubmissions": 2234567,
        "acceptanceRate": 48.9,
        "likes": 12470,
        "dislikes": 890,
        "averageRuntime": "52ms",
        "memoryUsage": "14.2MB"
      },
      "description": "## Problem Statement\n\nGiven an array of integers `nums` and an integer `target`, return **indices** of the two numbers such that they add up to `target`.\n\nYou may assume that each input would have **exactly one solution**, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n## Detailed Explanation\n\nYour task is to find two distinct indices `i` and `j` such that `nums[i] + nums[j] = target`. The indices should be different (`i != j`), but the values can be the same.\n\n**Important Notes:**\n- Each input has exactly one valid solution\n- You cannot use the same array element twice\n- The order of returned indices doesn't matter\n- Array indices are 0-based",
      "examples": [
        {
          "input": "nums = [2,7,11,15], target = 9",
          "output": "[0,1]",
          "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
        },
        {
          "input": "nums = [3,2,4], target = 6", 
          "output": "[1,2]",
          "explanation": "Because nums[1] + nums[2] == 6, we return [1, 2]."
        },
        {
          "input": "nums = [3,3], target = 6",
          "output": "[0,1]", 
          "explanation": "Because nums[0] + nums[1] == 6, we return [0, 1]. Note that both values are the same, but indices are different."
        }
      ],
      "constraints": [
        "2 ≤ nums.length ≤ 10^4",
        "-10^9 ≤ nums[i] ≤ 10^9", 
        "-10^9 ≤ target ≤ 10^9",
        "Only one valid answer exists"
      ],
      "hints": [
        "Try the brute force approach first. What is the time complexity?",
        "Can you improve the time complexity by using additional space?",
        "What if you store the complement of each number as you iterate?",
        "A hash map can help you find the complement in O(1) time."
      ],
      "testCases": [
        {
          "id": 1,
          "input": {
            "nums": [2, 7, 11, 15],
            "target": 9
          },
          "expectedOutput": [0, 1],
          "hidden": false,
          "description": "Basic example - first two elements"
        },
        {
          "id": 2,
          "input": {
            "nums": [3, 2, 4],
            "target": 6
          },
          "expectedOutput": [1, 2],
          "hidden": false,
          "description": "Solution not at the beginning"
        },
        {
          "id": 3,
          "input": {
            "nums": [3, 3],
            "target": 6
          },
          "expectedOutput": [0, 1],
          "hidden": false,
          "description": "Duplicate values, different indices"
        },
        {
          "id": 4,
          "input": {
            "nums": [1, 5, 3, 7, 2, 8],
            "target": 10
          },
          "expectedOutput": [1, 3],
          "hidden": true,
          "description": "Medium array size"
        },
        {
          "id": 5,
          "input": {
            "nums": [-1, -2, -3, -4, -5],
            "target": -8
          },
          "expectedOutput": [2, 4],
          "hidden": true,
          "description": "All negative numbers"
        },
        {
          "id": 6,
          "input": {
            "nums": [0, 4, 3, 0],
            "target": 0
          },
          "expectedOutput": [0, 3],
          "hidden": true,
          "description": "Zero values edge case"
        },
        {
          "id": 7,
          "input": {
            "nums": [-3, 4, 3, 90],
            "target": 0
          },
          "expectedOutput": [0, 2],
          "hidden": true,
          "description": "Positive and negative numbers"
        },
        {
          "id": 8,
          "input": {
            "nums": [1, 1, 1, 1, 1, 4, 1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1],
            "target": 11
          },
          "expectedOutput": [5, 11],
          "hidden": true,
          "description": "Many duplicate elements"
        },
        {
          "id": 9,
          "input": {
            "nums": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
            "target": 25
          },
          "expectedOutput": [4, 19],
          "hidden": true,
          "description": "Sequential array test"
        },
        {
          "id": 10,
          "input": {
            "nums": [1000000000, -1000000000, 0, 500000000, -500000000],
            "target": 0
          },
          "expectedOutput": [0, 1],
          "hidden": true,
          "description": "Extreme values - integer overflow edge case"
        },
        {
          "id": 11,
          "input": {
            "nums": "LARGE_ARRAY_PLACEHOLDER",
            "target": 0
          },
          "expectedOutput": "DYNAMIC_CALCULATION",
          "hidden": true,
          "description": "Maximum size array - MLE/TLE stress test"
        },
        {
          "id": 12,
          "input": {
            "nums": [2, 5, 5, 11],
            "target": 10
          },
          "expectedOutput": [1, 2],
          "hidden": true,
          "description": "Multiple same values, correct indices"
        }
      ],
      "followUp": [
        "What if the array is sorted?",
        "What if we need to find all pairs instead of just indices?",
        "Can you solve it in less than O(n) space?"
      ],
      "solution": {
        "approach": "Hash Map (Optimal)",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": "We can solve this in one pass by storing each number and its index in a hash map. For each number, we check if its complement (target - current number) exists in the map.",
        "algorithm": [
          "1. Create an empty hash map to store number -> index mapping",
          "2. Iterate through the array with index and value", 
          "3. Calculate complement = target - current number",
          "4. If complement exists in map, return [map[complement], current index]",
          "5. Otherwise, store current number and index in map",
          "6. Continue until solution is found"
        ],
        "code": {
          "python": "def twoSum(nums, target):\n    \"\"\"\n    Time: O(n), Space: O(n)\n    \"\"\"\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    return []  # No solution found",
          "java": "public int[] twoSum(int[] nums, int target) {\n    /*\n     * Time: O(n), Space: O(n)\n     */\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        if (map.containsKey(complement)) {\n            return new int[] { map.get(complement), i };\n        }\n        map.put(nums[i], i);\n    }\n    return new int[] {}; // No solution found\n}",
          "cpp": "vector<int> twoSum(vector<int>& nums, int target) {\n    /*\n     * Time: O(n), Space: O(n)\n     */\n    unordered_map<int, int> map;\n    for (int i = 0; i < nums.size(); i++) {\n        int complement = target - nums[i];\n        if (map.find(complement) != map.end()) {\n            return {map[complement], i};\n        }\n        map[nums[i]] = i;\n    }\n    return {}; // No solution found\n}",
          "javascript": "function twoSum(nums, target) {\n    /*\n     * Time: O(n), Space: O(n)\n     */\n    const map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        if (map.has(complement)) {\n            return [map.get(complement), i];\n        }\n        map.set(nums[i], i);\n    }\n    return []; // No solution found\n}"
        }
      },
      "alternativeSolutions": [
        {
          "approach": "Brute Force",
          "timeComplexity": "O(n²)",
          "spaceComplexity": "O(1)", 
          "description": "Check every pair of numbers",
          "code": {
            "python": "def twoSum(nums, target):\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    return []"
          }
        }
      ],
      "relatedProblems": [
        {
          "id": "3sum",
          "title": "3Sum", 
          "difficulty": "Medium"
        },
        {
          "id": "4sum",
          "title": "4Sum",
          "difficulty": "Medium" 
        },
        {
          "id": "two-sum-ii",
          "title": "Two Sum II - Input Array Is Sorted",
          "difficulty": "Easy"
        }
      ],
      "createdAt": "2024-01-15T10:00:00Z",
      "updatedAt": "2024-12-15T10:00:00Z"
    },
    {
      "id": "maximum-subarray",
      "title": "Maximum Subarray (Kadane's Algorithm)",
      "difficulty": "Medium",
      "level": 2,
      "category": "Dynamic Programming",
      "tags": ["Array", "Dynamic Programming", "Divide and Conquer"],
      "companies": [
        {
          "name": "Amazon",
          "frequency": "Very High", 
          "lastAsked": "2024-12-12"
        },
        {
          "name": "Microsoft",
          "frequency": "High",
          "lastAsked": "2024-12-05"
        },
        {
          "name": "Google",
          "frequency": "High",
          "lastAsked": "2024-11-28"
        },
        {
          "name": "Apple",
          "frequency": "Medium",
          "lastAsked": "2024-11-15"
        }
      ],
      "statistics": {
        "totalSubmissions": 2845673,
        "acceptedSubmissions": 1487234,
        "acceptanceRate": 52.3,
        "likes": 18760,
        "dislikes": 1120,
        "averageRuntime": "68ms",
        "memoryUsage": "15.1MB"
      },
      "description": "## Problem Statement\n\nGiven an integer array `nums`, find the **contiguous subarray** (containing at least one number) which has the largest sum and return **its sum**.\n\nA **subarray** is a contiguous part of an array.\n\n## Detailed Explanation\n\nYou need to find the maximum sum among all possible contiguous subarrays. The subarray must contain at least one element.\n\n**Key Points:**\n- The subarray must be contiguous (elements must be adjacent)\n- The subarray must contain at least one element\n- Return the sum, not the subarray itself\n- Handle negative numbers appropriately\n\n## Approach Hints\n\nThis is a classic Dynamic Programming problem that can be solved optimally using **Kadane's Algorithm**. The key insight is that at each position, you decide whether to:\n1. Start a new subarray from current element\n2. Extend the existing subarray by including current element",
      "examples": [
        {
          "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
          "output": "6",
          "explanation": "[4,-1,2,1] has the largest sum = 6."
        },
        {
          "input": "nums = [1]",
          "output": "1", 
          "explanation": "The array has only one element, so the maximum subarray sum is 1."
        },
        {
          "input": "nums = [5,4,-1,7,8]",
          "output": "23",
          "explanation": "The entire array [5,4,-1,7,8] has the largest sum = 23."
        },
        {
          "input": "nums = [-2,-3,-1,-5]",
          "output": "-1",
          "explanation": "The maximum subarray is [-1] with sum = -1."
        }
      ],
      "constraints": [
        "1 ≤ nums.length ≤ 10^5",
        "-10^4 ≤ nums[i] ≤ 10^4"
      ],
      "hints": [
        "Try to optimize the brute force approach that checks all subarrays.",
        "At each position, think about whether to start fresh or continue the current subarray.",
        "Kadane's algorithm: Keep track of maximum sum ending at current position.",
        "If current sum becomes negative, it's better to start fresh from next element."
      ],
      "testCases": [
        {
          "id": 1,
          "input": {
            "nums": [-2, 1, -3, 4, -1, 2, 1, -5, 4]
          },
          "expectedOutput": 6,
          "hidden": false,
          "description": "Classic example from problem statement"
        },
        {
          "id": 2,
          "input": {
            "nums": [1]
          },
          "expectedOutput": 1,
          "hidden": false, 
          "description": "Single element array"
        },
        {
          "id": 3,
          "input": {
            "nums": [5, 4, -1, 7, 8]
          },
          "expectedOutput": 23,
          "hidden": false,
          "description": "Entire array is the maximum subarray"
        },
        {
          "id": 4,
          "input": {
            "nums": [-2, -3, -1, -5]
          },
          "expectedOutput": -1,
          "hidden": true,
          "description": "All negative numbers"
        },
        {
          "id": 5,
          "input": {
            "nums": [0, -3, 1, 1]
          },
          "expectedOutput": 2,
          "hidden": true,
          "description": "Zero and negative numbers"
        },
        {
          "id": 6,
          "input": {
            "nums": [-1, 0, -2]
          },
          "expectedOutput": 0,
          "hidden": true,
          "description": "Zero is maximum"
        },
        {
          "id": 7,
          "input": {
            "nums": [2, -8, 3, -2, 4, -10, 6]
          },
          "expectedOutput": 6,
          "hidden": true,
          "description": "Multiple subarrays to consider"
        },
        {
          "id": 8,
          "input": {
            "nums": [1, -1, 1, -1, 1, -1, 1, -1, 1, -1]
          },
          "expectedOutput": 1,
          "hidden": true,
          "description": "Alternating positive/negative - edge case"
        },
        {
          "id": 9,
          "input": {
            "nums": "LARGE_RANDOM_ARRAY_PLACEHOLDER",
            "target": null
          },
          "expectedOutput": "DYNAMIC_CALCULATION",
          "hidden": true,
          "description": "Large random array - performance test"
        },
        {
          "id": 10,
          "input": {
            "nums": "LARGE_NEGATIVE_ARRAY_WITH_POSITIVE_END",
            "target": null
          },
          "expectedOutput": 10000,
          "hidden": true,
          "description": "Maximum size with mostly negatives - TLE test"
        },
        {
          "id": 11,
          "input": {
            "nums": "ALL_POSITIVE_LARGE_ARRAY",
            "target": null
          },
          "expectedOutput": "DYNAMIC_SUM_CALCULATION",
          "hidden": true,
          "description": "All positive numbers - large array MLE test"
        },
        {
          "id": 12,
          "input": {
            "nums": [10000, -5000, -5000, 10000]
          },
          "expectedOutput": 10000,
          "hidden": true,
          "description": "Large numbers edge case"
        }
      ],
      "solution": {
        "approach": "Kadane's Algorithm (Optimal)",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": "At each position, we decide whether to start a new subarray or extend the current one. If the current sum becomes negative, starting fresh is always better.",
        "algorithm": [
          "1. Initialize maxSum and currentSum with first element",
          "2. For each element from index 1:",
          "3.   currentSum = max(element, currentSum + element)",
          "4.   maxSum = max(maxSum, currentSum)", 
          "5. Return maxSum"
        ],
        "code": {
          "python": "def maxSubArray(nums):\n    \"\"\"\n    Kadane's Algorithm - O(n) time, O(1) space\n    \"\"\"\n    max_sum = current_sum = nums[0]\n    \n    for num in nums[1:]:\n        # Either start new subarray or extend existing\n        current_sum = max(num, current_sum + num)\n        # Update global maximum\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum",
          "java": "public int maxSubArray(int[] nums) {\n    /*\n     * Kadane's Algorithm - O(n) time, O(1) space\n     */\n    int maxSum = nums[0];\n    int currentSum = nums[0];\n    \n    for (int i = 1; i < nums.length; i++) {\n        // Either start new subarray or extend existing\n        currentSum = Math.max(nums[i], currentSum + nums[i]);\n        // Update global maximum\n        maxSum = Math.max(maxSum, currentSum);\n    }\n    \n    return maxSum;\n}",
          "cpp": "int maxSubArray(vector<int>& nums) {\n    /*\n     * Kadane's Algorithm - O(n) time, O(1) space\n     */\n    int maxSum = nums[0];\n    int currentSum = nums[0];\n    \n    for (int i = 1; i < nums.size(); i++) {\n        // Either start new subarray or extend existing\n        currentSum = max(nums[i], currentSum + nums[i]);\n        // Update global maximum\n        maxSum = max(max_sum, currentSum);\n    }\n    \n    return maxSum;\n}",
          "javascript": "function maxSubArray(nums) {\n    /*\n     * Kadane's Algorithm - O(n) time, O(1) space\n     */\n    let maxSum = nums[0];\n    let currentSum = nums[0];\n    \n    for (let i = 1; i < nums.length; i++) {\n        // Either start new subarray or extend existing\n        currentSum = Math.max(nums[i], currentSum + nums[i]);\n        // Update global maximum\n        maxSum = Math.max(maxSum, currentSum);\n    }\n    \n    return maxSum;\n}"
        }
      },
      "alternativeSolutions": [
        {
          "approach": "Brute Force",
          "timeComplexity": "O(n³)",
          "spaceComplexity": "O(1)",
          "description": "Check all possible subarrays",
          "code": {
            "python": "def maxSubArray(nums):\n    max_sum = float('-inf')\n    n = len(nums)\n    \n    for i in range(n):\n        for j in range(i, n):\n            current_sum = sum(nums[i:j+1])\n            max_sum = max(max_sum, current_sum)\n    \n    return max_sum"
          }
        },
        {
          "approach": "Divide and Conquer", 
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(log n)",
          "description": "Recursively divide array and find maximum in left, right, and crossing middle"
        }
      ],
      "followUp": [
        "If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach",
        "What if you need to return the actual subarray instead of just the sum?",
        "Can you solve this problem in 2D (maximum sum rectangle)?"
      ],
      "relatedProblems": [
        {
          "id": "maximum-product-subarray",
          "title": "Maximum Product Subarray",
          "difficulty": "Medium"
        },
        {
          "id": "best-time-to-buy-and-sell-stock", 
          "title": "Best Time to Buy and Sell Stock",
          "difficulty": "Easy"
        }
      ],
      "createdAt": "2024-01-17T10:00:00Z",
      "updatedAt": "2024-12-15T10:00:00Z"
    },
    {
      "id": "valid-parentheses",
      "title": "Valid Parentheses",
      "difficulty": "Easy",
      "level": 3,
      "category": "Stack",
      "tags": ["String", "Stack"],
      "companies": [
        {
          "name": "Facebook",
          "frequency": "High",
          "lastAsked": "2024-12-01"
        },
        {
          "name": "Microsoft",
          "frequency": "High",
          "lastAsked": "2024-11-20"
        },
        {
          "name": "Bloomberg",
          "frequency": "Medium",
          "lastAsked": "2024-11-15"
        }
      ],
      "statistics": {
        "totalSubmissions": 3456789,
        "acceptedSubmissions": 1876543,
        "acceptanceRate": 54.3,
        "likes": 9876,
        "dislikes": 432,
        "averageRuntime": "4ms",
        "memoryUsage": "6.3MB"
      },
      "description": "## Problem Statement\n\nGiven a string `s` containing just the characters `(`, `)`, `{`, `}`, `[` and `]`, determine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.",
      "examples": [
        {
          "input": "s = \"()\"",
          "output": "true"
        },
        {
          "input": "s = \"()[]{}\"",
          "output": "true"
        },
        {
          "input": "s = \"(]\" ",
          "output": "false"
        }
      ],
      "constraints": [
        "1 <= s.length <= 10^4",
        "s consists of parentheses only '()[]{}'."
      ],
      "hints": [
        "Use a stack to keep track of opening brackets.",
        "When you encounter a closing bracket, check if the top of the stack is the corresponding opening bracket.",
        "If the stack is empty at the end, the string is valid."
      ],
      "testCases": [
        {
          "id": 1,
          "input": {
            "s": "()"
          },
          "expectedOutput": true,
          "hidden": false,
          "description": "Simple case"
        },
        {
          "id": 2,
          "input": {
            "s": "()[]{}"
          },
          "expectedOutput": true,
          "hidden": false,
          "description": "Multiple bracket types"
        },
        {
          "id": 3,
          "input": {
            "s": "(]"
          },
          "expectedOutput": false,
          "hidden": false,
          "description": "Mismatched brackets"
        },
        {
          "id": 4,
          "input": {
            "s": "([)]"
          },
          "expectedOutput": false,
          "hidden": true,
          "description": "Incorrect order"
        },
        {
          "id": 5,
          "input": {
            "s": "{[]}"
          },
          "expectedOutput": true,
          "hidden": true,
          "description": "Nested brackets"
        }
      ],
      "solution": {
        "approach": "Stack",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": "The key to solving this problem is to use a stack. When we encounter an opening bracket, we push it onto the stack. When we encounter a closing bracket, we check if the top of the stack is the corresponding opening bracket. If it is, we pop the stack. If it is not, or if the stack is empty, the string is invalid. At the end, if the stack is empty, the string is valid.",
        "algorithm": [
          "1. Create an empty stack.",
          "2. Create a map to store the matching brackets.",
          "3. Iterate through the string.",
          "4. If the character is an opening bracket, push it onto the stack.",
          "5. If the character is a closing bracket, check if the stack is empty. If it is, return false.",
          "6. If the stack is not empty, pop the stack and check if the popped element is the corresponding opening bracket. If it is not, return false.",
          "7. At the end, if the stack is empty, return true. Otherwise, return false."
        ],
        "code": {
          "python": "def isValid(s):\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    for char in s:\n        if char in mapping:\n            top_element = stack.pop() if stack else '#\\'\n            if mapping[char] != top_element:\n                return False\n        else:\n            stack.append(char)\n    return not stack",
          "java": "public boolean isValid(String s) {\n    Stack<Character> stack = new Stack<Character>();\n    for (char c : s.toCharArray()) {\n        if (c == '(')\n            stack.push(')');\n        else if (c == '{')\n            stack.push('}');\n        else if (c == '[')\n            stack.push(']');\n        else if (stack.isEmpty() || stack.pop() != c)\n            return false;\n    }\n    return stack.isEmpty();\n}",
          "cpp": "bool isValid(string s) {\n    stack<char> st;\n    for (char c : s) {\n        if (c == '(' || c == '{' || c == '[') {\n            st.push(c);\n        } else {\n            if (st.empty() || (st.top() == '(' && c != ')') || (st.top() == '{' && c != '}') || (st.top() == '[' && c != ']')) {\n                return false;\n            }\n            st.pop();\n        }\n    }\n    return st.empty();\n}",
          "javascript": "var isValid = function(s) {\n    const stack = [];\n    const map = {\n        \"(\": \")\",\n        \"{\": \"}\",\n        \"[\": \"]\"\n    };\n    for (let i = 0; i < s.length; i++) {\n        let c = s[i];\n        if (map[c]) {\n            stack.push(map[c]);\n        } else if (c !== stack.pop()) {\n            return false;\n        }\n    }\n    return !stack.length;\n}"
        }
      },
      "createdAt": "2025-08-10T12:00:00Z",
      "updatedAt": "2025-08-10T12:00:00Z"
    }
  ],
  "metadata": {
    "totalProblems": 3,
    "difficultyDistribution": {
      "Easy": 2,
      "Medium": 1,
      "Hard": 0
    },
    "categoryDistribution": {
      "Arrays": 1,
      "Dynamic Programming": 1,
      "Stack": 1
    },
    "lastUpdated": "2025-08-10T12:00:00Z"
  }
}